import { response } from "express";
import sdk from "matrix-js-sdk";
import dotenv from "dotenv";
dotenv.config();
import axios from "axios";
import crypto from "crypto"
import { access } from "fs";

// Initializing a client with the admin user credentials
const MatrixClient = async (userId,accessToken) =>{
    return sdk.createClient({
        baseUrl: 'http://localhost:8008',
        accessToken: accessToken,
        userId: userId             
    })
} 

function generateMac(nonce, user, password, admin=false, userType=null, sharedSecret){
    const hmac = crypto.createHmac('sha1', sharedSecret);

    hmac.update(Buffer.from(nonce,'utf8')); //Encoding nonce as UTF-8
    hmac.update(Buffer.from("\x00"));   //Appending null byte
    hmac.update(Buffer.from(user,'utf8'));  // Encoding user as UTF-8
    hmac.update(Buffer.from("\x00"));   // Appending null byte
    hmac.update(Buffer.from(password,'utf8'));  // Encoding password as UTF-8
    hmac.update(Buffer.from("\x00"));   // Appending null byte
    hmac.update(Buffer.from(admin? "admin" : "notadmin", "utf8"));  // Adding 'admin' or 'notadmin'

    if (userType){
        hmac.update(Buffer.from("\x00"));   //Appending null byte
        hmac.update(Buffer.from(userType, "utf8")); // Encoding userType if provided
    }

    return hmac.digest('hex');
}

class MatrixService {
    //Registering a new Matrix users
    static async registerUser(username,password){
        try{
            const url = "http://localhost:8008/_synapse/admin/v1/register";

            // Acquiring nonce (random code generated by synapse) using a get request to the synapse server
            const nonceResponse = await axios.get(
                url,
                {
                    headers: {
                        Authorization: `Bearer ${process.env.synapse_admin_access_token}`,
                    }
                }
            );
            
            const nonce = nonceResponse.data.nonce;
            const response = await axios.post(
                url,
                {
                    nonce: nonce,
                    mac: generateMac(nonce,username,password,false,null,process.env.synapse_secret_key),
                    username: username,
                    password: password,
                    admin: false
                },
                {
                    headers: {
                        Authorization: `Bearer ${process.env.synapse_admin_access_token}`,
                        "Content-Type": "application/json"
                    }
                }
            )
            return response.data;
        }catch(error){
            console.error("Failed to register user:", error.response?.data || error.message);
            throw error;
        }
    }

    //Creating a new room (chat session)
    static async createRoom(userId,accessToken,inviteUserId,isGroupChat=false,roomName = null){
        try{
            const matrixClient = await MatrixClient(userId,accessToken);
            const options = isGroupChat? {name:roomName,invite:inviteUserId ,preset:"trusted_private_chat"} : {invite:[inviteUserId], preset:"trusted_private_chat"}
            const room = await matrixClient.createRoom(options);
            return room;
        }catch(error){
            console.error("Failed to create room:", error.response || error.message || error);
            throw error;
        }
    }

    //Add user to the room (sending invitation)
    static async addUserToRoom(roomId, userId){
        try{
            const matrixClient = await MatrixClient(req);
            const response = await matrixClient.invite(roomId, userId);
            return response.message;
        }catch(error){
            console.error("Failed to add user to room:",error.message);
        }
    }

    // Load invitations for the user
    static async listInvitations(userId, accessToken) {
        try {
            const matrixClient = await MatrixClient(userId,accessToken);
    
            // Start syncing to get the latest state
            matrixClient.startClient({
                initialSyncLimit: 10, // Number of events to fetch in the initial sync
            });
    
            return new Promise((resolve, reject) => {
                const invitedRooms = [];
    
                // Listen for sync completion
                matrixClient.once("sync", (state) => {
                    if (state === "ERROR") {
                        reject(new Error("Failed to sync with the server."));
                    }
                });
    
                // Listen for room updates
                matrixClient.on("Room", (room) => {
                    if (room.getMyMembership() === "invite") {
                        // Safely retrieve room invitation details
                        const roomNameEvent = room.currentState.getStateEvents("m.room.name", "");
                        const roomName =
                            roomNameEvent?.getContent()?.name || "Unnamed Room";

                        const inviterEvent = room.currentState.getStateEvents(
                            "m.room.member",
                            userId
                        );

                        const inviter = inviterEvent?.getSender?.() || "Unknown Inviter";

                        invitedRooms.push({
                            roomId: room.roomId,
                            name: roomName,
                            inviter: inviter,
                        });
                    }
                });
    
                // Allow some time for invitations to be processed
                setTimeout(() => {
                    matrixClient.stopClient(); // Stop the client after processing
                    resolve(invitedRooms);
                }, 3000); // Adjust timeout as needed
            });
        } catch (error) {
            console.error("Failed to list invitations:", error.message);
            throw error;
        }
    }

    //Accepting the invite to a room
    static async acceptInvite(roomId, userId, accessToken){
        try{
            const matrixClient = await MatrixClient(userId, accessToken);
            const response = await matrixClient.joinRoom(roomId);
            return response;
        }catch(error){
            console.error("Failed to accept invite:", error.message)
        }
    }

    //Send a message in a room
    static async sendMessage(roomId,senderId, message, accessToken){
        try{
            const matrixClient = await MatrixClient(senderId,accessToken);
            await matrixClient.sendEvent(roomId, "m.room.message", {
                msgtype: "m.text",
                body: message
            });
        }catch(error){
            console.error("Failed to send message:", error.message);
            throw error;
        }
    }

    //Get message from a room
    static async getMessage(roomId){
        try{
            const matrixClient = await MatrixClient(req);
            const response = await matrixClient.roomInitialSync(roomId);
            return response.messages;
        }catch(error){
            console.error("Failed to retrieve messages:", error.message);
            throw error;
        }
    }

}

export default MatrixService;
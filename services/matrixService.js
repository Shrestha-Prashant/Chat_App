import { response } from "express";
import sdk from "matrix-js-sdk";
import dotenv from "dotenv";
dotenv.config();
import axios from "axios";
import crypto from "crypto"
import queryMembershipSnapshots from "../models/synapse.js";

// Initializing a client with the admin user credentials
const MatrixClient = async (userId,accessToken) =>{
    return sdk.createClient({
        baseUrl: 'http://localhost:8008',
        accessToken: accessToken,
        userId: userId,     
    })
} 

function generateMac(nonce, user, password, admin=false, userType=null, sharedSecret){
    const hmac = crypto.createHmac('sha1', sharedSecret);

    hmac.update(Buffer.from(nonce,'utf8')); //Encoding nonce as UTF-8
    hmac.update(Buffer.from("\x00"));   //Appending null byte
    hmac.update(Buffer.from(user,'utf8'));  // Encoding user as UTF-8
    hmac.update(Buffer.from("\x00"));   // Appending null byte
    hmac.update(Buffer.from(password,'utf8'));  // Encoding password as UTF-8
    hmac.update(Buffer.from("\x00"));   // Appending null byte
    hmac.update(Buffer.from(admin? "admin" : "notadmin", "utf8"));  // Adding 'admin' or 'notadmin'

    if (userType){
        hmac.update(Buffer.from("\x00"));   //Appending null byte
        hmac.update(Buffer.from(userType, "utf8")); // Encoding userType if provided
    }

    return hmac.digest('hex');
}

class MatrixService {
    //Registering a new Matrix users
    static async registerUser(username,password){
        try{
            const url = "http://localhost:8008/_synapse/admin/v1/register";

            // Acquiring nonce (random code generated by synapse) using a get request to the synapse server
            const nonceResponse = await axios.get(
                url,
                {
                    headers: {
                        Authorization: `Bearer ${process.env.synapse_admin_access_token}`,
                    }
                }
            );
            
            const nonce = nonceResponse.data.nonce;
            const response = await axios.post(
                url,
                {
                    nonce: nonce,
                    mac: generateMac(nonce,username,password,false,null,process.env.synapse_secret_key),
                    username: username,
                    password: password,
                    admin: false
                },
                {
                    headers: {
                        Authorization: `Bearer ${process.env.synapse_admin_access_token}`,
                        "Content-Type": "application/json"
                    }
                }
            )
            return response.data;
        }catch(error){
            console.error("Failed to register user:", error.response?.data || error.message);
            throw error;
        }
    }

    //Creating a new room (chat session)
    static async createRoom(userId,accessToken,inviteUserId,isGroupChat=false,roomName = null){
        try{
            const matrixClient = await MatrixClient(userId,accessToken);
            const options = isGroupChat? {name:roomName,invite:inviteUserId ,preset:"trusted_private_chat"} : {invite:[inviteUserId], preset:"trusted_private_chat"}
            const room = await matrixClient.createRoom(options);
            if(validateRoomCreation){
                return room;
            }
            else{
                return null
            }
        }catch(error){
            console.error("Failed to create room:", error.response || error.message || error);
            throw error;
        }
    }

    //Add user to the room (sending invitation)
    static async addUserToRoom(roomId, userId, accessToken){
        try{
            const matrixClient = await MatrixClient(userId,accessToken);
            const response = await matrixClient.invite(roomId, userId);
            console.log(response)
            return response.message;
        }catch(error){
            console.error("Failed to add user to room:",error.message);
        }
    }

    static async listInvitations(userId,accessToken) {
        try {
            await MatrixClient(userId,accessToken);
            const response = await queryMembershipSnapshots(userId);
            return response;
        } catch (error) {
            console.error("Error fetching room invitations:", error.message);
            throw error;
        }
    }
    

    //List joined rooms
    static async loadRooms(userId, accessToken) {
        try {
            const matrixClient = await MatrixClient(userId,accessToken)
            await matrixClient.startClient({ initialSyncLimit: 0 });
    
            // Wait for the client to sync
            await new Promise((resolve) => matrixClient.once("sync", resolve));
    
            const joinedRooms = matrixClient.getRooms();
    
            const roomDetails = {};
            for (const room of joinedRooms) {
                const roomId = room.roomId;
                const roomName = room.name || room.getCanonicalAlias() || "Unnamed Room";
    
                roomDetails[roomId] = roomName;
            }
    
            // Stop the client to clean up resources
            matrixClient.stopClient();
            return roomDetails;
        } catch (error) {
            console.error("Failed to load rooms:", error.message);
        }
    }
    

    //Accepting the invite to a room
    static async acceptInvite(roomId, userId, accessToken){
        try{
            const matrixClient = await MatrixClient(userId, accessToken);
            const response = await matrixClient.joinRoom(roomId);
            return response;
        }catch(error){
            console.error("Failed to accept invite:", error.message)
        }
    }

    //Send a message in a room
    // addition of a file in message
    static async sendMessage(roomId,senderId, message, accessToken){
        try{
            const matrixClient = await MatrixClient(senderId,accessToken);
            await matrixClient.sendEvent(roomId, "m.room.message", {
                msgtype: "m.text",
                body: message
            });
        }catch(error){
            console.error("Failed to send message:", error.message);
            throw error;
        }
    }

    //Get message from a room
    static async getMessage(roomId,userId,accessToken){
        try{
            const matrixClient = await MatrixClient(userId,accessToken);
            const response = await matrixClient.roomInitialSync(roomId);
            return response.messages;
        }catch(error){
            console.error("Failed to retrieve messages:", error.message);
            throw error;
        }
    }

}

export default MatrixService;